#include <ros/ros.h>
#include <image_transport/image_transport.h>
#include <cv_bridge/cv_bridge.h>
#include <sensor_msgs/image_encodings.h>
#include <opencv2/imgproc/imgproc.hpp>
#include <opencv2/highgui/highgui.hpp>
#include "my_fit/control_param.h"
#include <geometry_msgs/Twist.h>

static ros::NodeHandle nh_;
ros::Publisher pub_=nh_.advertise<geometry_msgs::Twist>("/mobile_base/commands/velocity", 1);

 void  callback(const my_fit::control_param::ConstPtr& msg)
{
    ROS_INFO(" control_param is %f and %f !!!",msg->dist,	 msg->theta);
    float d=msg->dist;//dist>0:left  ; dist<0:right;
    float t=msg->theta;//theat>0:conterclockwise  ; theta<0:clockwise
    geometry_msgs::Twist  twist_msg;
     twist_msg.angular.x=0;
     twist_msg.angular.y=0;
     twist_msg.angular.z=0;
     twist_msg.linear.x=0.1;
     twist_msg.linear.y=0;
     twist_msg.linear.z=0;
      ////第二种情况；角度ok，距离越界
    if(d>10&&abs(t)<0.1)
    {
     twist_msg.angular.x=0;
     twist_msg.angular.y=0;
     twist_msg.angular.z=0.1;
     twist_msg.linear.x=0.2;
     twist_msg.linear.y=0;
     twist_msg.linear.z=0;
    	
    }
    if(d<-10&&abs(t)<0.1)
       {
            twist_msg.angular.x=0;
   	  twist_msg.angular.y=0;
   	  twist_msg.angular.z=-0.1;
   	  twist_msg.linear.x=0.2;
    	  twist_msg.linear.y=0;
   	  twist_msg.linear.z=0;
       }
    ////第三种情况；距离ok，角度越界
    if(abs(d)<10&&t>0.1)
       {
       	 twist_msg.angular.Vector3_(0,0,-0.1);
       	 twist_msg.linear.Vector3_(0.0,0,0);
       }
    if(abs(d)<10&&t<-0.1)
       {
       	 twist_msg.angular.Vector3_(0,0,0.1);
       	 twist_msg.linear.Vector3_(0.0,0,0);
       }
    ////第四种情况；距离和角度均不符；
    if((d<-10&&t<-0.1)||(d>10&&t>0.1))
    {
    	twist_msg.angular.Vector3_(0,0,0.0);
    	twist_msg.linear.Vector3_(0.2,0,0);
    }
    if((d<-10&&t>0.1))
        {
        	twist_msg.angular.Vector3_(0,0,-0.1);
        	twist_msg.linear.Vector3_(0.0,0,0);
        }
    if(d>10&&t<-0.1)
        {
        	twist_msg.angular.Vector3_(0,0,0.1);
        	twist_msg.linear.Vector3_(0.0,0,0);
        }

    pub_.publish(twist_msg);
    cv::waitKey(200);

}
int main(int argc, char** argv)
{
  ros::init(argc, argv, "my_controller");

  ros::Subscriber sub_=nh_.subscribe("/myfit/control_param", 1000,callback);
  ROS_INFO("my_controller  has been init   and wait for arrival of control_param !!!");
  ros::spin();
  return 0;
}

